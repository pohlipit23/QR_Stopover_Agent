{"version":3,"sources":["../../src/core/with-plugins.ts"],"sourcesContent":["import type { AstroIntegration, HookParameters } from \"astro\";\r\nimport type { NonEmptyArray, Prettify } from \"../internal/types.js\";\r\nimport type { AddedParam, AnyPlugin, ExtendedHooks, Hooks } from \"./types.js\";\r\n\r\ntype WithPluginsParams<TPlugins extends NonEmptyArray<AnyPlugin>> = {\r\n\tname: string;\r\n\tplugins: TPlugins;\r\n\thooks: ExtendedHooks<TPlugins>;\r\n};\r\n\r\nexport type WithPluginsReturn<Extensions> = Extensions &\r\n\tOmit<AstroIntegration, \"name\">;\r\n\r\n/**\r\n * Allows to extend hooks with custom parameters. Only used for advanced use-cases.\r\n *\r\n * @param {object} params\r\n * @param {string} params.name The integration name\r\n * @param {Array<AnyPlugin>} params.plugins\r\n * @param {import(\"astro\".AstroIntegration[\"hooks\"])} params.hooks\r\n */\r\nexport const withPlugins = <\r\n\tTPlugins extends NonEmptyArray<AnyPlugin>,\r\n\tExtensions extends Record<any, unknown>,\r\n>(\r\n\toptions: WithPluginsParams<TPlugins> & Extensions,\r\n): WithPluginsReturn<\r\n\tPrettify<Omit<Extensions, keyof WithPluginsParams<any>>>\r\n> => {\r\n\tconst {\r\n\t\tname,\r\n\t\tplugins,\r\n\t\thooks: providedHooks,\r\n\t\t...remainingIntegrationObject\r\n\t} = options;\r\n\r\n\t// Overrides plugins with same name\r\n\t// Overrides plugins with same name, keeping only the last occurrence\r\n\tconst resolvedPlugins = plugins\r\n\t\t.filter(\r\n\t\t\t(plugin, index, self) =>\r\n\t\t\t\tself.findLastIndex((other) => other.name === plugin.name) === index,\r\n\t\t)\r\n\t\t// Setup plugins with the integration parameters\r\n\t\t.map(\r\n\t\t\t(\r\n\t\t\t\tplugin,\r\n\t\t\t): Partial<\r\n\t\t\t\tRecord<keyof Hooks, (params: any) => Record<string, unknown>>\r\n\t\t\t> => plugin.setup({ name }),\r\n\t\t);\r\n\r\n\tconst definedHooks = ([\r\n\t\t...Object.keys(providedHooks),\r\n\t\t...resolvedPlugins.flatMap(Object.keys),\r\n\t] as Array<keyof Hooks>)\r\n\t\t// Deduplicate the hook names\r\n\t\t.filter((hookName, index, list) => list.indexOf(hookName) === index);\r\n\r\n\tconst hooks: AstroIntegration[\"hooks\"] = Object.fromEntries(\r\n\t\tdefinedHooks.map((hookName) => [\r\n\t\t\thookName,\r\n\t\t\t// We know all hook parameters are objects, but the generic correlation makes TS ignore that fact.\r\n\t\t\t// The intersection with `object` is a workaround so TS doesn't complain about the spread below.\r\n\t\t\t(params: object & HookParameters<typeof hookName>) => {\r\n\t\t\t\tconst plugins = resolvedPlugins.filter(\r\n\t\t\t\t\t(p): p is Required<Pick<typeof p, typeof hookName>> =>\r\n\t\t\t\t\t\thookName in p && !!p[hookName],\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst additionalParams = {} as AddedParam<TPlugins, typeof hookName>;\r\n\r\n\t\t\t\tfor (const plugin of plugins) {\r\n\t\t\t\t\tObject.assign(additionalParams, plugin[hookName](params));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn providedHooks[hookName]?.({\r\n\t\t\t\t\t...additionalParams,\r\n\t\t\t\t\t...params,\r\n\t\t\t\t} as any);\r\n\t\t\t},\r\n\t\t]),\r\n\t);\r\n\r\n\treturn {\r\n\t\thooks,\r\n\t\t...remainingIntegrationObject,\r\n\t};\r\n};\r\n"],"mappings":"AAqBO,IAAMA,EAIZC,GAGI,CACJ,GAAM,CACL,KAAAC,EACA,QAAAC,EACA,MAAOC,EACP,GAAGC,CACJ,EAAIJ,EAIEK,EAAkBH,EACtB,OACA,CAACI,EAAQC,EAAOC,IACfA,EAAK,cAAeC,GAAUA,EAAM,OAASH,EAAO,IAAI,IAAMC,CAChE,EAEC,IAECD,GAGIA,EAAO,MAAM,CAAE,KAAAL,CAAK,CAAC,CAC3B,EAEKS,EAAgB,CACrB,GAAG,OAAO,KAAKP,CAAa,EAC5B,GAAGE,EAAgB,QAAQ,OAAO,IAAI,CACvC,EAEE,OAAO,CAACM,EAAUJ,EAAOK,IAASA,EAAK,QAAQD,CAAQ,IAAMJ,CAAK,EA2BpE,MAAO,CACN,MA1BwC,OAAO,YAC/CG,EAAa,IAAKC,GAAa,CAC9BA,EAGCE,GAAqD,CACrD,IAAMX,EAAUG,EAAgB,OAC9BS,GACAH,KAAYG,GAAK,CAAC,CAACA,EAAEH,CAAQ,CAC/B,EAEMI,EAAmB,CAAC,EAE1B,QAAWT,KAAUJ,EACpB,OAAO,OAAOa,EAAkBT,EAAOK,CAAQ,EAAEE,CAAM,CAAC,EAGzD,OAAOV,EAAcQ,CAAQ,IAAI,CAChC,GAAGI,EACH,GAAGF,CACJ,CAAQ,CACT,CACD,CAAC,CACF,EAIC,GAAGT,CACJ,CACD","names":["withPlugins","options","name","plugins","providedHooks","remainingIntegrationObject","resolvedPlugins","plugin","index","self","other","definedHooks","hookName","list","params","p","additionalParams"]}